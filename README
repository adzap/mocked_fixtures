MockedFixtures
==============

Yes, lets laugh at those silly fixtures with their silly yaml or even comma 
separated values! Ha ha ha! Don't they know how passe they are. All the cool kids
are mocking and stubbing. Get with the times fixtures!

Well actually fixtures still have their place. Especially with the foxy fixtures
extensions added to Rails Deux. This plugin adds the ability to use fixtures as 
mocked model objects rather than load in them into the database. So you can now 
reuse those thoughtfully crafted fixtures but minus the database overhead. This 
particularly speeds up tests where the database is not needed (or wanted) such 
as in controller and view specs.

A mocked fixture is a mocked model object with all the model attributes stubbed
out to return the values from the fixture if defined. If no fixture value was 
defined then a nil is returned for the attribute method. There are no 
expectations set on the mock, thats where you come in. But the time saved comes 
from the assumption you won't be setting expectations on all your model 
attributes.

This can make life much simpler in your controller/view specs or functional 
tests as they can go from this:

	before do
		@joe = mock_model(People)
		@joe.stub!(:first_name).and_return('Joe')
		@joe.stub!(:last_name).and_return('Blow')
		@joe.stub!(:sex).and_return('Male')
		...
	end
	
To this:

	mock_fixtures :people

	before do
		@joe = mock_people(:joe)
		# Done. Plus you also have any other fixtures waiting in the wings. Now
		# just add any expectations you need to make them a 'real' mock object.
	end

But I hear you say you can do the first example inline, which is true. But 
still it can be tedious for lesser model attributes. If you have a nice fixture 
you used for your model specs then why not reuse it eh?! Also if you have many 
attributes which you are stubbing just so the controller or view spec don't 
throw an error, then this can make short work for you.

Again none of this touches the database as all model attributes are read from
schema.rb file. Nice, huh?!

If you are using SQLServer adapter, included is a fix for AR to get the schema 
dumper to correctly output the primary key in your schema.rb if other than id. 
We need this to avoid a database hit. You will need to do a dump before using 
this plugin. How's that for a pre-requisite!


Install
======

To use it install as a plugin

	piston import URL_TO_COME vendor/plugins/mocked_fixtures
	
Then in your 'test_helper.rb' or 'spec_helper.rb' file:
	
	require 'mocked_fixtures'

This line must be *above* the require 'spec/rails' line in your spec_helper.rb 
file.


Usage
=====

To use it in your tests or specs at the top of the test case or describe
block put:
	
	mock_fixtures :people 

just like you would with the normal fixtures class method.

Then in your test method or example you call:
	
	@joey = mock_people(:joe)

If you have a people fixture labelled 'joe' you will get back the mocked
model object to play with that has all the values from the fixture returned when
the attribute methods are called.

Also you can,

	@people = mock_people(:all)

to get the array of mocked models. This might be a dubious extension as you
usually want to know exactly what you are getting back. But again it can save 
typing in those views spec when you just need a list of records.

Now remember the mocked objects are just simple mocked models and the 
attributes only stubbed readers not writers. This is the same as
mock_model(YourModel, :attr1 => 'blah') using RSpec, because thats exactly what
it is.


Disclaimer
==========

This plugin is coupled tightly to the Rails fixtures api and implementation so
it may be prone to breaking with successive versions of Rails. The reason for
this was to avoid re-implementating the foxy fixtures features.


Feedback
========

If you have feedback or suggestions Google has kindly donated me this email
address to contact me:

  Adam Meehan (adam.meehan@gmail.com)
  
Mock on!
